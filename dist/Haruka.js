// Generated by CoffeeScript 2.3.1
//! ========================================
//! The Haruka class
var Discord, Haruka, fs;

fs = require('fs');

Discord = require('discord.js');

/**
 * The Haruka class.
 * @author MindfulMinun
 * @param {Object} options - Haruka’s options.
 * @param {Object} options.config - The configuration file.
    See `example-config.json`
 * @param {Object} options.version - Haruka’s version.
    Defaults to `options.config.version`
 * @param {Object} options.prefix - Haruka’s command prefix, such as `-h`.
    This must be defined.
 * @since 2.0.0
 * @version 2.0.0
 */
Haruka = class Haruka {
  constructor(options) {
    var ref, ref1, ref2;
    // Set a couple variables for later
    this.client = new Discord.Client;
    this.config = (ref = options.config) != null ? ref : {};
    this.version = (ref1 = options.version) != null ? ref1 : this.config.version;
    this.prefix = (function() {
      var ref3;
      if ((ref2 = (ref3 = options.prefix) != null ? ref3 : this.config.prefix) != null) {
        return ref2;
      } else {
        throw Error("Haruka requires a command prefix.");
      }
    }).call(this);
    /**
     * A collection of functions, meant to be added via
     * `Haruka::add('function', fn)`
     */
    this.functions = [];
    /**
     * A collection of special functions, meant to be
     * added via `Haruka::add('special', fn)`
     */
    this.specials = [];
  }

  /**
   * Haruka will attempt to reply to the given Discord message.
   * @author MindfulMinun
   * @param {Message} msg - The discord.js Discord message
   * @returns {*} The return value of the handler function
  or `undefined` if none was called.
   * @since 0.1.0
   * @version 2.0.0
   */
  try(msg) {
    var fn, i, j, len, len1, ref, ref1, regexMatch, temp, txt;
    ref = this.specials;
    //! ========================================
    //! Run Specials first
    for (i = 0, len = ref.length; i < len; i++) {
      fn = ref[i];
      //! Break if handler returns a truthy value.
      if (temp = fn.handler(msg, this)) {
        return temp;
      }
    }
    //! ========================================
    //! Functions

    //! Tokenize input
    txt = msg.content.tokenize();
    txt[1] = txt[1] ? txt[1] : "help";
    //! Check if the message starts with the prefix,
    //! and it's not from another bot.
    if ((txt[0] !== this.prefix) || msg.author.bot) {
      return;
    }
    ref1 = this.functions;
    //! Run through all the commands and see if one matches.
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      fn = ref1[j];
      regexMatch = fn.regex.exec(txt[1]);
      if (regexMatch) {
        return fn.handler(msg, regexMatch, this);
      }
    }
    //! Catchall
    return msg.reply(["Hmm, I'm not sure what you mean by that.", "Sorry, I don't know what you meant by that.", "I’m not sure I understand.", "I’m not sure what you mean."].choose() + " Try `-h help` for a list of commands.");
  }

  /**
   * Adds a function to Haruka’s queue
   * @author MindfulMinun
   * @param {String} type - An enumerated string, either
  "function" or "special"
   * @returns {Haruka} The Haruka object with the function added to it.
   * @since Sep 23, 2018 - 2.0.0
   * @version 2.0.0
   */
  add(type, fn) {
    switch (type) {
      case "function":
        this.functions.push(fn);
        break;
      case "special":
        this.specials.push(fn);
        break;
      default:
        throw Error(`Expected type to be either “function” or “special”, was instead “${type}”`);
    }
    return this;
  }

};

module.exports = Haruka;
