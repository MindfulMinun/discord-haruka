// Generated by CoffeeScript 2.5.1
//! ========================================
//! Anime
var Discord, asyncReq, handler, query, relative, request, url;

Discord = require('discord.js');

request = require('request');

relative = require(`${__dirname}/../helpers/relative`);

asyncReq = function(options) {
  return new Promise(function(resolve, reject) {
    return request(options, function(err, response, body) {
      var ref, ref1;
      // coffeelint: disable=max_line_length
      if (!err && ((200 <= (ref = response.statusCode) && ref < 400)) && !((ref1 = JSON.parse(body)) != null ? ref1.errors : void 0)) {
        // coffeelint: enable=max_line_length
        return resolve(JSON.parse(body));
      }
      return reject([err, response, body]);
    });
  });
};

query = `query ($search: String) {
    Media(search: $search, type: ANIME) {
        title {
            english
            romaji
            native
        }
        description(asHtml: false)
        averageScore
        nextAiringEpisode {
            airingAt
        }
        status
        siteUrl
        episodes
        duration
        genres
        coverImage {
            large
        }
        bannerImage
        synonyms
    }
}`;

url = 'https://graphql.anilist.co';

handler = function(msg, match, Haruka) {
  var animeRequest, options;
  animeRequest = match.input.tokenize()[1];
  if (!animeRequest) {
    return msg.reply(["Use `-h anime` followed by an anime to search for that anime."].choose());
  }
  options = {
    url: url,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    body: JSON.stringify({
      query: query,
      variables: {
        search: animeRequest
      }
    })
  };
  return asyncReq(options).then(function(results) {
    var a, desc, embed, nextAiringDate, ref, ref1, ref2, ref3, ref4, status;
    a = results.data.Media;
    desc = (function() {
      var temp;
      temp = a.description.split(' ').slice(0, 50).join(' ');
      if (temp === a.description) {
        return temp.replace(/<[^>]*>/g, '');
      } else {
        return temp.replace(/<[^>]*>/g, '') + '...';
      }
    })();
    status = ["FINISHED", "RELEASING", "NOT_YET_RELEASED", "CANCELLED"].indexOf(a.status);
    embed = new Discord.RichEmbed().setColor('#448aff').setTitle((ref = (ref1 = a.title.romaji) != null ? ref1 : a.title.english) != null ? ref : a.title.native).setURL(a.siteUrl).setDescription(desc).setThumbnail(a.coverImage.large).setFooter("Powered by the AniList API");
    if (a.duration != null) {
      embed.addField("Episode Duration (average)", `${a.duration} min`, true);
    }
    if (a.episodes != null) {
      embed.addField("Episode Count", `${a.episodes}`, true);
    }
    if (a.averageScore != null) {
      embed.addField("Score", `${a.averageScore} out of 100`, true);
    }
    if (status !== -1) {
      status = (function() {
        switch (status) {
          case 0:
            return "Completed";
          case 1:
            return "Currently airing";
          case 2:
            return "Not yet airing";
          case 3:
            return "Canceled";
        }
      })();
      embed.addField("Status", status, true);
    }
    if (((ref2 = a.nextAiringEpisode) != null ? ref2.airingAt : void 0) != null) {
      nextAiringDate = new Date(a.nextAiringEpisode.airingAt * 1000);
      embed.addField("Next episode airs...", `${relative(nextAiringDate)}`, true);
    }
    if (((ref3 = a.synonyms) != null ? ref3.length : void 0) > 0) {
      embed.addField("Alternate names", a.synonyms.join(', '), true);
    }
    if (((ref4 = a.genres) != null ? ref4.length : void 0) > 0) {
      embed.addField("Genres", a.genres.join(', '), true);
    }
    return msg.channel.send(`Results for “${animeRequest}”`, {
      disableEveryone: true,
      embed: embed
    });
  }).catch(function(err) {
    var body, response;
    console.log(err);
    response = null;
    body = null;
    if (err instanceof Array) {
      [err, response, body] = err;
    }
    if (!body) {
      return msg.channel.send(["Hmm, I couldn’t find that anime. Did you spell it right?"]);
    }
    if (body != null ? body.errors : void 0) {
      return msg.channel.send(`A server error occurred, it's not my fault this time :D

\`\`\`json
${JSON.stringify(body.errors)}
\`\`\``);
    }
  });
};

module.exports = {
  name: "Anime",
  regex: /^(anime|animu|japanime)(\s+|$)/i,
  handler: handler,
  help: {
    short: "-h anime <...> :: Retrieves info regarding some anime.",
    long: `\`\`\`asciidoc
=== Help for Anime ===
*Aliases*: anime, animu, japanime
-h anime <query> :: Searches for an anime provided a search term.
\`\`\``
  }
};
