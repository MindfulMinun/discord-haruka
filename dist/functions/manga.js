// Generated by CoffeeScript 2.3.1
//! ========================================
//! Manga

// NOTE: This code is pretty much a duplicate of `anime.coffee`
// any changes made here should reflect `anime` as well.
var Discord, asyncReq, handler, query, relative, request, url;

Discord = require('discord.js');

request = require('request');

relative = require(`${__dirname}/../helpers/relative`);

asyncReq = function(options) {
  return new Promise(function(resolve, reject) {
    return request(options, function(err, response, body) {
      var ref, ref1;
      // coffeelint: disable=max_line_length
      if (!err && ((200 <= (ref = response.statusCode) && ref < 400)) && !((ref1 = JSON.parse(body)) != null ? ref1.errors : void 0)) {
        // coffeelint: enable=max_line_length
        return resolve(JSON.parse(body));
      }
      return reject([err, response, body]);
    });
  });
};

query = 'query ($search: String) {\n    Media(search: $search, type: MANGA) {\n        title {\n            english\n            romaji\n            native\n        }\n        description(asHtml: false)\n        averageScore\n        status\n        siteUrl\n        chapters\n        volumes\n        genres\n        coverImage {\n            large\n        }\n        bannerImage\n        synonyms\n    }\n}';

url = 'https://graphql.anilist.co';

handler = function(msg, match, Haruka) {
  var mangaRequest, options;
  mangaRequest = match.input.tokenize()[1];
  if (!mangaRequest) {
    return msg.reply(["Use `-h manga` followed by an manga to search for that manga."].choose());
  }
  options = {
    url: url,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    body: JSON.stringify({
      query: query,
      variables: {
        search: mangaRequest
      }
    })
  };
  return asyncReq(options).then(function(results) {
    var a, desc, embed, ref, ref1, ref2, ref3, status;
    a = results.data.Media;
    desc = (function() {
      var temp;
      temp = a.description.split(' ').slice(0, 50).join(' ');
      if (temp === a.description) {
        return temp.replace(/<[^>]*>/g, '');
      } else {
        return temp.replace(/<[^>]*>/g, '') + '...';
      }
    })();
    status = ["FINISHED", "RELEASING", "NOT_YET_RELEASED", "CANCELLED"].indexOf(a.status);
    embed = new Discord.RichEmbed().setColor('#448aff').setTitle((ref = (ref1 = a.title.romaji) != null ? ref1 : a.title.english) != null ? ref : a.title.native).setURL(a.siteUrl).setDescription(desc).setThumbnail(a.coverImage.large).setFooter("Powered by the AniList API");
    if (a.chapters != null) {
      embed.addField("Chapter count", `${a.chapters}`, true);
    }
    if (a.volumes != null) {
      embed.addField("Volume count", `${a.volumes}`, true);
    }
    if (a.averageScore != null) {
      embed.addField("Score", `${a.averageScore} out of 100`, true);
    }
    if (status !== -1) {
      status = (function() {
        switch (status) {
          case 0:
            return "Completed";
          case 1:
            return "Currently releasing";
          case 2:
            return "Not yet released";
          case 3:
            return "Canceled";
        }
      })();
      embed.addField("Status", status, true);
    }
    if (((ref2 = a.synonyms) != null ? ref2.length : void 0) > 0) {
      embed.addField("Alternate names", a.synonyms.join(', '), true);
    }
    if (((ref3 = a.genres) != null ? ref3.length : void 0) > 0) {
      embed.addField("Genres", a.genres.join(', '), true);
    }
    return msg.channel.send(`Results for “${mangaRequest}”`, {
      disableEveryone: true,
      embed: embed
    });
  }).catch(function(err) {
    var body, response;
    console.log(err);
    response = null;
    body = null;
    if (err instanceof Array) {
      [err, response, body] = err;
    }
    if (!body) {
      return msg.channel.send(["Hmm, I couldn’t find that manga. Did you spell it right?"]);
    }
    if (body != null ? body.errors : void 0) {
      return msg.channel.send(`A server error occurred, it's not my fault this time :D\n\n\`\`\`json\n${JSON.stringify(body.errors)}\n\`\`\``);
    }
  });
};

module.exports = {
  name: "Manga",
  regex: /^(manga|doujin)(\s+|$)/i,
  handler: handler,
  help: {
    short: "-h manga <...> :: Retrieves info regarding some manga.",
    long: "```asciidoc\n=== Help for Manga ===\n*Aliases*: manga, doujin\n-h manga <query> :: Searches for a mange provided a search term.\n```"
  }
};
